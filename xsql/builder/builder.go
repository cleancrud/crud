// Code generated by bcurd

package builder

import (
	"context"
	"database/sql"
	"errors"

	"github.com/happycrud/crud/xsql"

	"time"
)

type Model interface {
	Values() []interface{}
	GetId() int64
	SetId(id int64)
	ScanDst(columns []string) []interface{}
	SelectCheck(columns []string) error
	Columns() []string
}

// InsertBuilder InsertBuilder
type InsertBuilder[T Model] struct {
	eq      xsql.ExecQuerier
	builder *xsql.InsertBuilder
	a       []T
	upsert  bool
	timeout time.Duration
}

// Create Create
func Create[T Model](eq xsql.ExecQuerier, table string) *InsertBuilder[T] {

	return &InsertBuilder[T]{
		builder: xsql.Insert(table),
		eq:      eq,
	}
}

// Timeout SetTimeout
func (in *InsertBuilder[T]) Timeout(t time.Duration) *InsertBuilder[T] {
	in.timeout = t
	return in
}

// SetUser SetUser
func (in *InsertBuilder[T]) SetT(a ...T) *InsertBuilder[T] {
	in.a = append(in.a, a...)
	return in
}

// Upsert update all field when insert conflict
func (in *InsertBuilder[T]) Upsert(ctx context.Context) (int64, error) {
	in.upsert = true
	return in.Save(ctx)
}

// Save Save one or many records set by SetUser method
// if insert a record , the LastInsertId  will be setted on the struct's  PrimeKey field
// if insert many records , every struct's PrimeKey field will not be setted
// return number of RowsAffected or error
func (in *InsertBuilder[T]) Save(ctx context.Context) (int64, error) {
	if len(in.a) == 0 {
		return 0, errors.New("please set a User")
	}
	var temp T
	in.builder.Columns(temp.Columns()...)
	if in.upsert {
		in.builder.OnDuplicateKeyUpdate(temp.Columns()...)
	}
	for _, a := range in.a {
		in.builder.Values(a.Values())
	}
	_, ctx, cancel := xsql.Shrink(ctx, in.timeout)
	defer cancel()
	ins, args := in.builder.Query()
	result, err := in.eq.ExecContext(ctx, ins, args...)
	if err != nil {
		return 0, err
	}

	lastInsertId, err := result.LastInsertId()
	if err != nil {
		return 0, err
	}
	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return rowsAffected, err
	}
	if lastInsertId > 0 && rowsAffected > 0 {
		for _, v := range in.a {
			if v.GetId() > 0 {
				continue
			}
			v.SetId(int64(lastInsertId))
			lastInsertId++
		}
	}

	return result.RowsAffected()
}

// DeleteBuilder DeleteBuilder
type DeleteBuilder[T Model] struct {
	builder *xsql.DeleteBuilder
	eq      xsql.ExecQuerier
	timeout time.Duration
}

// Delete Delete
func Delete[T Model](eq xsql.ExecQuerier, table string) *DeleteBuilder[T] {
	return &DeleteBuilder[T]{
		builder: xsql.Delete(table),
		eq:      eq,
	}
}

// Timeout SetTimeout
func (d *DeleteBuilder[T]) Timeout(t time.Duration) *DeleteBuilder[T] {
	d.timeout = t
	return d
}

// Where  UserWhere
func (d *DeleteBuilder[T]) Where(p ...xsql.WhereFunc) *DeleteBuilder[T] {
	s := &xsql.Selector{}
	for _, v := range p {
		v(s)
	}
	d.builder = d.builder.Where(s.P())
	return d
}

// Exec Exec
func (d *DeleteBuilder[T]) Exec(ctx context.Context) (int64, error) {
	_, ctx, cancel := xsql.Shrink(ctx, d.timeout)
	defer cancel()
	del, args := d.builder.Query()
	res, err := d.eq.ExecContext(ctx, del, args...)
	if err != nil {
		return 0, err
	}
	return res.RowsAffected()
}

// SelectBuilder SelectBuilder
type SelectBuilder[T Model] struct {
	builder *xsql.Selector
	eq      xsql.ExecQuerier
	timeout time.Duration
}

// Find Find
func Find[T Model](eq xsql.ExecQuerier, table string) *SelectBuilder[T] {

	sel := &SelectBuilder[T]{
		builder: xsql.Select(),
		eq:      eq,
	}
	sel.builder = sel.builder.From(xsql.Table(table))
	return sel
}

// Timeout SetTimeout
func (s *SelectBuilder[T]) Timeout(t time.Duration) *SelectBuilder[T] {
	s.timeout = t
	return s
}

// Select Select
func (s *SelectBuilder[T]) Select(columns ...string) *SelectBuilder[T] {
	s.builder.Select(columns...)
	return s
}

// Count Count
func (s *SelectBuilder[T]) Count(columns ...string) *SelectBuilder[T] {
	s.builder.Count(columns...)
	return s
}

// Where where
func (s *SelectBuilder[T]) Where(p ...xsql.WhereFunc) *SelectBuilder[T] {
	sel := &xsql.Selector{}
	for _, v := range p {
		v(sel)
	}
	s.builder = s.builder.Where(sel.P())
	return s
}

func (s *SelectBuilder[T]) WhereP(ps ...*xsql.Predicate) *SelectBuilder[T] {
	for _, v := range ps {
		s.builder.Where(v)
	}
	return s
}

// Offset Offset
func (s *SelectBuilder[T]) Offset(offset int32) *SelectBuilder[T] {
	s.builder = s.builder.Offset(int(offset))
	return s
}

// Limit Limit
func (s *SelectBuilder[T]) Limit(limit int32) *SelectBuilder[T] {
	s.builder = s.builder.Limit(int(limit))
	return s
}

// OrderDesc OrderDesc
func (s *SelectBuilder[T]) OrderDesc(field string) *SelectBuilder[T] {
	s.builder = s.builder.OrderBy(xsql.Desc(field))
	return s
}

// OrderAsc OrderAsc
func (s *SelectBuilder[T]) OrderAsc(field string) *SelectBuilder[T] {
	s.builder = s.builder.OrderBy(xsql.Asc(field))
	return s
}

// ForceIndex ForceIndex  FORCE INDEX (`index_name`)
func (s *SelectBuilder[T]) ForceIndex(indexName ...string) *SelectBuilder[T] {
	s.builder.ForceIndex(indexName...)
	return s
}

// GroupBy GroupBy
func (s *SelectBuilder[T]) GroupBy(fields ...string) *SelectBuilder[T] {
	s.builder.GroupBy(fields...)
	return s
}

// Having Having
func (s *SelectBuilder[T]) Having(p *xsql.Predicate) *SelectBuilder[T] {
	s.builder.Having(p)
	return s
}

// Slice Slice scan query result to slice
func (s *SelectBuilder[T]) Slice(ctx context.Context, dstSlice interface{}) error {
	_, ctx, cancel := xsql.Shrink(ctx, s.timeout)
	defer cancel()
	sqlstr, args := s.builder.Query()
	q, err := s.eq.QueryContext(ctx, sqlstr, args...)
	if err != nil {
		return err
	}
	defer q.Close()
	return xsql.ScanSlice(q, dstSlice)
}

// One One
func (s *SelectBuilder[T]) One(ctx context.Context) (*T, error) {
	s.builder.Limit(1)
	results, err := s.All(ctx)
	if err != nil {
		return nil, err
	}
	if len(results) <= 0 {
		return nil, sql.ErrNoRows
	}
	return results[0], nil
}

// Int64 count or select only one int64 field
func (s *SelectBuilder[T]) Int64(ctx context.Context) (int64, error) {
	_, ctx, cancel := xsql.Shrink(ctx, s.timeout)
	defer cancel()
	return xsql.Int64(ctx, s.builder, s.eq)
}

// Int64s return int64 slice
func (s *SelectBuilder[T]) Int64s(ctx context.Context) ([]int64, error) {
	_, ctx, cancel := xsql.Shrink(ctx, s.timeout)
	defer cancel()
	return xsql.Int64s(ctx, s.builder, s.eq)
}

// String  String
func (s *SelectBuilder[T]) String(ctx context.Context) (string, error) {
	_, ctx, cancel := xsql.Shrink(ctx, s.timeout)
	defer cancel()
	return xsql.String(ctx, s.builder, s.eq)
}

// Strings return string slice
func (s *SelectBuilder[T]) Strings(ctx context.Context) ([]string, error) {
	_, ctx, cancel := xsql.Shrink(ctx, s.timeout)
	defer cancel()
	return xsql.Strings(ctx, s.builder, s.eq)
}

// All  return all results
func (s *SelectBuilder[T]) All(ctx context.Context) ([]*T, error) {
	var selectedColumns []string
	var a T
	if s.builder.SelectColumnsLen() <= 0 {
		s.builder.Select(a.Columns()...)
		selectedColumns = a.Columns()
	} else {
		selectedColumns = s.builder.SelectedColumns()
		var a T
		if err := a.SelectCheck(selectedColumns); err != nil {
			return nil, err
		}
	}
	_, ctx, cancel := xsql.Shrink(ctx, s.timeout)
	defer cancel()
	sqlstr, args := s.builder.Query()
	q, err := s.eq.QueryContext(ctx, sqlstr, args...)
	if err != nil {
		return nil, err
	}
	defer q.Close()
	result := []*T{}
	for q.Next() {
		var a T
		dst := a.ScanDst(selectedColumns)
		if err := q.Scan(dst...); err != nil {
			return nil, err
		}
		result = append(result, &a)
	}
	if q.Err() != nil {
		return nil, q.Err()
	}
	return result, nil
}

// UpdateBuilder UpdateBuilder
type UpdateBuilder[T Model] struct {
	builder *xsql.UpdateBuilder
	eq      xsql.ExecQuerier
	timeout time.Duration
}

// Update return a UpdateBuilder
func Update[T Model](eq xsql.ExecQuerier, table string) *UpdateBuilder[T] {
	return &UpdateBuilder[T]{
		eq:      eq,
		builder: xsql.Update(table),
	}
}

// Timeout SetTimeout
func (u *UpdateBuilder[T]) Timeout(t time.Duration) *UpdateBuilder[T] {
	u.timeout = t
	return u
}

// Where Where
func (u *UpdateBuilder[T]) Where(p ...xsql.WhereFunc) *UpdateBuilder[T] {
	s := &xsql.Selector{}
	for _, v := range p {
		v(s)
	}
	u.builder = u.builder.Where(s.P())
	return u
}

// SetId  set id
func (u *UpdateBuilder[T]) Set(name string, arg int64) *UpdateBuilder[T] {
	u.builder.Set(name, arg)
	return u
}

// Save do a update statment  if tx can without context
func (u *UpdateBuilder[T]) Save(ctx context.Context) (int64, error) {
	_, ctx, cancel := xsql.Shrink(ctx, u.timeout)
	defer cancel()
	up, args := u.builder.Query()
	result, err := u.eq.ExecContext(ctx, up, args...)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

// func (a User) ScanDst(columns []string) []interface{} {
// 	dst := make([]interface{}, 0, len(columns))
// 	for _, v := range columns {
// 		switch v {
// 		case Id:
// 			dst = append(dst, &a.Id)
// 		case Name:
// 			dst = append(dst, &a.Name)
// 		case Age:
// 			dst = append(dst, &a.Age)
// 		case Ctime:
// 			dst = append(dst, &a.Ctime)
// 		case Mtime:
// 			dst = append(dst, &a.Mtime)
// 		}
// 	}
// 	return dst
// }
// func (a *User) SelectCheck(columns []string) error {
// 	for _, v := range columns {
// 		if _, ok := columnsSet[v]; !ok {
// 			return errors.New("User not have field:" + v)
// 		}
// 	}
// 	return nil
// }

// func (a User) Values() []interface{} {
// 	return []interface{}{a.Id, a.Name, a.Age, a.Ctime, a.Mtime}
// }
// func (a User) GetId() int64 {
// 	return a.Id
// }
// func (a *User) SetId(id int64) {
// 	a.Id = id
// }

// func (a *User) Columns() []string {
// 	return columns
// }

// var UserCreate = func(db xsql.ExecQuerier) *builder.InsertBuilder[*User] {
// 	return builder.Create[*User](db, table)
// }

// var UserFind = func(db xsql.ExecQuerier) *builder.SelectBuilder[*User] {
// 	return builder.Find[*User](db, table)
// }
// var UserDelete = func(db xsql.ExecQuerier) *builder.DeleteBuilder[*User] {
// 	return builder.Delete[*User](db, table)
// }
// var UserUpdate = func(db xsql.ExecQuerier) *builder.UpdateBuilder[*User] {
// 	return builder.Update[*User](db, table)
// }
